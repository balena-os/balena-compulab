From 6abe3c27dcc2aaf3e19ff436604f21fbe18699aa Mon Sep 17 00:00:00 2001
From: Vicentiu Galanopulo <vicentiu@balena.io>
Date: Tue, 5 Oct 2021 14:34:17 +0200
Subject: [PATCH] Add EEPROM EtcherPro versioning based on board hw version

 * Enable the I2C4 bus to enable EEPROM communication
 * Use i2c commands to read from the EEPROM the EP version
 * Set the read EP version as env variable
 * Add logic to load diffrent dtbs based on EP versions
 * Add GPIO board specific settings based on EP versions

Upstream-Status: Inappropriate [configuration]
Signed-off-by: Vicentiu Galanopulo <vicentiu@balena.io>
---
 arch/arm/dts/cl-som-imx8.dts             |  14 ++
 board/compulab/cl-som-imx8/cl-som-imx8.c | 188 +++++++++++++++++++++--
 cmd/i2c.c                                |   2 +-
 include/configs/cl-som-imx8.h            |  15 +-
 4 files changed, 203 insertions(+), 16 deletions(-)

diff --git a/arch/arm/dts/cl-som-imx8.dts b/arch/arm/dts/cl-som-imx8.dts
index 6bd2efd953..bce589bb52 100644
--- a/arch/arm/dts/cl-som-imx8.dts
+++ b/arch/arm/dts/cl-som-imx8.dts
@@ -121,6 +121,13 @@
 			>;
 		};
 
+		pinctrl_i2c4: i2c4grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_I2C4_SCL_I2C4_SCL			0x4000007f
+				 MX8MQ_IOMUXC_I2C4_SDA_I2C4_SDA			0x4000007f
+			>;
+		};
+
 		pinctrl_i2c1_gpio: i2c1grp-gpio {
 			fsl,pins = <
 				MX8MQ_IOMUXC_I2C1_SCL_GPIO5_IO14        		0x7f
@@ -391,6 +398,13 @@
 
 };
 
+&i2c4 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c4>;
+	status = "okay";
+};
+
 &uart3 { /* console */
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_uart3>;
diff --git a/board/compulab/cl-som-imx8/cl-som-imx8.c b/board/compulab/cl-som-imx8/cl-som-imx8.c
index 248000a23c..9616e08695 100644
--- a/board/compulab/cl-som-imx8/cl-som-imx8.c
+++ b/board/compulab/cl-som-imx8/cl-som-imx8.c
@@ -27,9 +27,20 @@
 
 #include <usb.h>
 #include <dwc3-uboot.h>
+#include <env_internal.h>
+#include <search.h>
+#include <errno.h>
+#ifdef CONFIG_DM_I2C
+#include <i2c.h>
+#include <dm.h>
+#define DISP_LINE_LEN	16
+extern struct udevice *i2c_cur_bus;
+#endif
 
 DECLARE_GLOBAL_DATA_PTR;
 
+static char ep_version[9];
+
 #ifdef CONFIG_BOARD_POSTCLK_INIT
 int board_postclk_init(void)
 {
@@ -321,6 +332,91 @@ static void setup_pcie_vph(void)
 
 }
 
+#ifdef CONFIG_DM_I2C
+enum i2c_err_op {
+	I2C_ERR_READ,
+	I2C_ERR_WRITE,
+};
+
+static int i2c_report_err(int ret, enum i2c_err_op op)
+{
+	printf("Error %s the chip: %d\n",
+	    op == I2C_ERR_READ ? "reading" : "writing", ret);
+
+	return -1;
+}
+
+static int cmd_i2c_set_bus_num(unsigned int busnum)
+{
+	struct udevice *bus;
+	int ret;
+
+	ret = uclass_get_device_by_seq(UCLASS_I2C, busnum, &bus);
+	if (ret) {
+		printf("%s: No bus %d\n", __func__, busnum);
+		return ret;
+	}
+	i2c_cur_bus = bus;
+
+	return 0;
+}
+
+static int i2c_get_cur_bus(struct udevice **busp)
+{
+	if (!i2c_cur_bus) {
+		puts("No I2C bus selected\n");
+		return -ENODEV;
+	}
+	*busp = i2c_cur_bus;
+
+	return 0;
+}
+
+static int i2c_get_cur_bus_chip(uint chip_addr, struct udevice **devp)
+{
+	struct udevice *bus;
+	int ret;
+
+	ret = i2c_get_cur_bus(&bus);
+	if (ret)
+		return ret;
+
+	return i2c_get_chip(bus, chip_addr, 1, devp);
+}
+
+static int eeprom_get_etcher_pro_rev(char **ep_version) {
+	int ret = 0;
+	int alen = 2;
+	uint addr = 0x00;
+	int linebytes = 4; /* for testing EP revision will be 4 bytes */
+	unsigned char linebuf[DISP_LINE_LEN];
+	struct udevice *dev;
+
+	ret = cmd_i2c_set_bus_num(3);
+	if (ret)
+		printf("Failure changing bus number (%d)\n", ret);
+
+	ret = i2c_get_cur_bus_chip(0x51, &dev);
+
+	if (!ret && alen != -1)
+		ret = i2c_set_chip_offset_len(dev, alen);
+
+	if (ret)
+		return i2c_report_err(ret, I2C_ERR_READ);
+
+	ret = dm_i2c_read(dev, addr, linebuf, linebytes);
+
+	if (ret)
+		return i2c_report_err(ret, I2C_ERR_READ);
+	else {
+		snprintf(ep_version, sizeof(ep_version) +  1, "%02X%02X%02X%02X", linebuf[0],
+		linebuf[1], linebuf[2], linebuf[3]);
+	}
+
+	return ret;
+}
+#endif
+
 
 int board_init(void)
 {
@@ -332,25 +428,82 @@ int board_init(void)
 #ifdef CONFIG_FEC_MXC
 	setup_fec();
 #endif
+
+	ep_version[0] = '\0';
+#ifdef CONFIG_DM_I2C
+	int ret = eeprom_get_etcher_pro_rev(&ep_version);
+	if (ret)
+		printf("EP version could not be read from EEPROM\n Defaulting to latest hw version\n");
+#endif
+
 	setup_usbmux();
 
-	gpio_request(IMX_GPIO_NR(4, 5),"tft_stdby");
-	gpio_direction_output(IMX_GPIO_NR(4, 5), 1);
+	if (strlen(ep_version)) {
+		if (strcmp(ep_version,"02510103") == 0) {
+			debug("MIPI display - ep version 2.2\n");
 
-	gpio_request(IMX_GPIO_NR(5, 18),"tft_bcl_pwm");
-	gpio_direction_output(IMX_GPIO_NR(5, 18), 1);
+			gpio_request(IMX_GPIO_NR(4, 5),"tft_stdby");
+			gpio_direction_output(IMX_GPIO_NR(4, 5), 1);
 
-	gpio_request(IMX_GPIO_NR(5, 4),"pwm_fan");
-	gpio_direction_output(IMX_GPIO_NR(5, 4), 1);
+			gpio_request(IMX_GPIO_NR(5, 18),"tft_bcl_pwm");
+			gpio_direction_output(IMX_GPIO_NR(5, 18), 0);
 
-	gpio_request(IMX_GPIO_NR(4, 7),"uPCIe_1_RST");
-	gpio_direction_output(IMX_GPIO_NR(4, 7), 1);
+			gpio_request(IMX_GPIO_NR(4, 1),"tft_shlr");
+			gpio_direction_output(IMX_GPIO_NR(4, 1), 0);
 
-	gpio_request(IMX_GPIO_NR(4, 23),"reset_led");
-	gpio_direction_output(IMX_GPIO_NR(4, 23), 1);
+			gpio_request(IMX_GPIO_NR(4, 16),"tft_updw");
+			gpio_direction_output(IMX_GPIO_NR(4, 16), 1);
 
-	gpio_request(IMX_GPIO_NR(5, 3),"led_outenable");
-	gpio_direction_output(IMX_GPIO_NR(5, 3), 0);
+			gpio_request(IMX_GPIO_NR(3, 25),"tft_rst");
+			gpio_direction_output(IMX_GPIO_NR(3, 25), 1);
+		} else if (strcmp(ep_version,"02460010") == 0) {
+			debug("HDMI version, no display config needed\n");
+		} else {
+			// default EP version (latest) 2.3
+			gpio_request(IMX_GPIO_NR(4, 5),"tft_stdby");
+			gpio_direction_output(IMX_GPIO_NR(4, 5), 1);
+
+			gpio_request(IMX_GPIO_NR(5, 18),"tft_bcl_pwm");
+			gpio_direction_output(IMX_GPIO_NR(5, 18), 1);
+
+			gpio_request(IMX_GPIO_NR(5, 4),"pwm_fan");
+			gpio_direction_output(IMX_GPIO_NR(5, 4), 1);
+
+			gpio_request(IMX_GPIO_NR(4, 7),"uPCIe_1_RST");
+			gpio_direction_output(IMX_GPIO_NR(4, 7), 1);
+
+			gpio_request(IMX_GPIO_NR(4, 23),"reset_led");
+			gpio_direction_output(IMX_GPIO_NR(4, 23), 1);
+
+			gpio_request(IMX_GPIO_NR(5, 3),"led_outenable");
+			gpio_direction_output(IMX_GPIO_NR(5, 3), 0);
+
+			gpio_request(IMX_GPIO_NR(5, 22),"pm_uart1_rx");
+			gpio_direction_output(IMX_GPIO_NR(5, 22), 0);
+		}
+	} else {
+		// default EP version (latest) 2.3
+		gpio_request(IMX_GPIO_NR(4, 5),"tft_stdby");
+		gpio_direction_output(IMX_GPIO_NR(4, 5), 1);
+
+		gpio_request(IMX_GPIO_NR(5, 18),"tft_bcl_pwm");
+		gpio_direction_output(IMX_GPIO_NR(5, 18), 1);
+
+		gpio_request(IMX_GPIO_NR(5, 4),"pwm_fan");
+		gpio_direction_output(IMX_GPIO_NR(5, 4), 1);
+
+		gpio_request(IMX_GPIO_NR(4, 7),"uPCIe_1_RST");
+		gpio_direction_output(IMX_GPIO_NR(4, 7), 1);
+
+		gpio_request(IMX_GPIO_NR(4, 23),"reset_led");
+		gpio_direction_output(IMX_GPIO_NR(4, 23), 1);
+
+		gpio_request(IMX_GPIO_NR(5, 3),"led_outenable");
+		gpio_direction_output(IMX_GPIO_NR(5, 3), 0);
+
+		gpio_request(IMX_GPIO_NR(5, 22),"pm_uart1_rx");
+		gpio_direction_output(IMX_GPIO_NR(5, 22), 0);
+	}
 
 #if defined(CONFIG_USB_DWC3) || defined(CONFIG_USB_XHCI_IMX8M)
 	init_usb_clk();
@@ -403,6 +556,17 @@ int board_late_init(void)
 #endif
 	board_bootdev_init();
 
+	if (strlen(ep_version)) {
+		struct env_entry e, *ep;
+		e.key	= "ep_version";
+		e.data	= ep_version;
+		hsearch_r(e, ENV_ENTER, &ep, &env_htab, H_PROGRAMMATIC);
+		if (!ep) {
+			printf("## Error inserting \"%s\" variable, errno=%d\n",
+			ep_version, errno);
+		}
+	}
+
 	ret = setup_mac_address();
 	if (ret < 0)
 		printf("%s: Can't set MAC address\n", __func__);
diff --git a/cmd/i2c.c b/cmd/i2c.c
index 43a76299b3..b363f5b8b3 100644
--- a/cmd/i2c.c
+++ b/cmd/i2c.c
@@ -129,7 +129,7 @@ static uchar i2c_no_probes[] = CONFIG_SYS_I2C_NOPROBES;
 #endif
 
 #ifdef CONFIG_DM_I2C
-static struct udevice *i2c_cur_bus;
+struct udevice *i2c_cur_bus;
 
 static int cmd_i2c_set_bus_num(unsigned int busnum)
 {
diff --git a/include/configs/cl-som-imx8.h b/include/configs/cl-som-imx8.h
index e6ba700c4d..1afeed9979 100644
--- a/include/configs/cl-som-imx8.h
+++ b/include/configs/cl-som-imx8.h
@@ -69,7 +69,15 @@
 	"console=ttymxc2,115200 earlycon=ec_imx6q,0x30880000,115200\0" \
 	"fdt_addr=0x43000000\0"			\
 	"fdt_high=0xffffffffffffffff\0"		\
-	"fdt_file="CONFIG_DEFAULT_DTB"\0" \
+	"set_fdt_file=if test ${ep_version} = 02460010; then " \
+			    "setenv fdt_file sbc-imx8-no-wp_v2.46.0+rev10.dtb; " \
+			"else " \
+			    "if test ${ep_version} = 02510103; then " \
+				"setenv fdt_file sbc-imx8-no-wp_v2.51.1+rev3.dtb;" \
+			    "else " \
+				"setenv fdt_file sbc-imx8-no-wp.dtb;" \
+			    "fi;" \
+			"fi;\0" \
 	"initrd_addr=0x43800000\0"		\
 	"initrd_high=0xffffffffffffffff\0" \
 	"mmcautodetect=yes\0" \
@@ -79,7 +87,7 @@
 	"iface_boot=if run loadbootscript; then run bootscript; else if run loadimage; then run loadfdt;" \
 	" booti ${loadaddr} - ${fdt_addr}; fi; fi;\0"	\
 	"iface_args=setenv bootargs console=${console} root=${rootdev} ${resin_kernel_root} rootwait rw ${os_cmdline} "\
-	"video=HDMI-A-1:1920x1080@60 \0"	\
+	"video=HDMI-A-1:1920x1080@60 ep_version=${ep_version}\0"	\
 	"loadbootscript=load ${iface} ${dev}:${part} ${loadaddr} ${script}\0"	\
 	"loadfdt=load ${iface} ${dev}:${part} ${fdt_addr} ${fdt_file}\0"	\
 	"loadimage=load ${iface} ${dev}:${part} ${zip_addr} ${image}; unzip ${zip_addr} ${loadaddr};\0"	\
@@ -97,11 +105,12 @@
 	"run resin_set_kernel_root; run set_os_cmdline; " \
 	"setenv mmcdev ${resin_dev_index};" \
 	"setenv mmcbootpart ${resin_boot_part};" \
+	"run set_fdt_file;" \
 	"run mmc_boot; echo ERROR Could not boot from emmc device ${mmcdev};"
 
 #ifdef CONFIG_ENV_SIZE
 #undef CONFIG_ENV_SIZE
-#define CONFIG_ENV_SIZE             0x6000
+#define CONFIG_ENV_SIZE             0x7000
 #endif
 
 /* Link Definitions */
-- 
2.17.1

